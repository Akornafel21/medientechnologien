<html>
<head>
<title></title>
<link rel="stylesheet" type="text/css" href="format.css">
<style type="text/css">
        
                 a:link {font-family:Arial;        font-size:10pt;        text-decoration:none;}
                a:visited {font-family:Arial; font-size:10pt; text-decoration:none;}
                a:hover {color:#FF3333; text-decoration:none; font-weight:normal; font-size:10pt;}
     
</style>
</head>

<body>

<iframe src="oben.html" width="800" height="120" name="IFrame3" id="IFrame3" scrolling="no" frameborder="0">
         <p>Ihr Browser kann leider keine eingebe5tteten Frames anzeigen:Sie k&ouml;nnen die eingebettete Seite &uuml;ber den
         folgenden.</p>
</iframe>

<h1>Uebung 2</h1>
<h2>Bild-Grundlagen: Abtastung, Aliasing, Quantisierung</h2>
<br><h3>Aufgabe 1 - 1.1</h3>
<p>Erzeuge aus den beiden JPG-Bildern, die dir geschickt wurden, Bitmap-Bilder (BMP) im Format 960x540 Pixel, 24Bit</p>
<table><tr>
<td><img src="./pics/Koala.jpg" alt="Koalabaer auf dem Baum" width="350" height="300"></td>
<td><img src="./pics/Penguins.jpg" alt="Penguins auf dem Eis" width="350" height="300"></td>
</tr></table>
<br><h3>Aufgabe 1 - 1.2</h3>
<p>Nun lies die Bilder mit bmp_io ein und erkläre die Angaben im Header, die auf der Konsole ausgegeben werden! </p>
<br><p><!--Lösung-->-</p>

<br><p>Wie erklärt sich die Dateigröße für die beiden Dateien?</p>
<p><!--Lösung-->-</p>

<br><h2>Aufgabe 2 - Aliasing</h2>
<br><h3>Aufgabe 2 - 2.1</h3>
<p>Modifiziere bmp_io dahingehend, dass die RGB Werte der einzelnen Pixel in der BMP-Datei in eine (lesbare) ASCII-Datei geschrieben werden. <br>Es reichen dabei jeweils eine
    Zeile und eine Spalte! Lies die von mir geschickten Testdateien ein <br>und schätze aus den resultierenden Zahlenfolgen die Periodendauer in Pixeln in horizontaler und vertikaler
    Richtung. <br>(Jeweils eine Periode horizontal und eine vertikal für das Übungsprotokoll abspeichern).</p>
<img src="./pics/stadt.png" alt="Marsch &uuml;ber die Stra&szlig;e" width="450" height="300">
<p>Bescheibung</p>
<p>Loesung</p>

<br><h3>Aufgabe 2 - 2.2</h3>
<p>Auch bei der Bildabtastung muss das sogenannte Abtasttheorem eingehalten werden. 
    <br>Wie lautet es und wie läßt sich der Grenzfall, für den es gerade noch gilt, illustrieren
    (Zeichnung !)?</p>
<p><!--Lösung-->-</p>

<br><h3>Aufgabe 2 - 2.3</h3>
<p>Erzeuge aus deinen eigenen Farbbildern Graustufen-Bilder. <br>Dazu muss der Helligkeitswert Y aus den RGB-Werten errechnet werden. 
    Es gibt dafür verschiedene Ansätze.<br>
    Nutze die Formel Y= 0,3 x R + 0,6 x G + 0,1 x B, die die Helligkeitsempfindlichkeit des Auges annähert. Mit diesem Y-Wert wird dann die R, G und B-Information überschrieben.
    Speichere die Graustufenbilder ab.</p>
<p><!--Lösung-->-</p>

<br><h3>Aufgabe 2 - 2.4</h3>
<p>Erkläre, wie bei Bild- und Videoaufnahmen Aliasing entstehen kann. Ähnlich wie bei der 1. Übung am Audiosignal wollen wir auf das Bild ein Down-Sampling anwenden und
    sehen, wann dabei Aliasing auftritt. Beim Audiosignal haben wir jedes zweite Sample verworfen und damit die Abtastfrequenz halbiert. Beim Bild verringern wir die räumliche
    Auflösung, indem wir die Zahl der Bildzeilen bzw. Bildspalten verringern. Dabei wollen wir das Bild allerdings nicht verkleinern - was normalerweise die Folge wäre - sondern einfach
    die ungeradzahligen Spalten durch den Inhalt der geradzahligen Spalten ersetzen, d.h. Spalte 1 wird durch Spalte 0 ersetzt, Spalte 3 durch Spalte 2 etc. und analog für die Zeilen.
    Wenn das Ursprungsbild nun sehr feine Strukturen aufweist, wie in machen Testdateien, können Aliasing-Verzerrungen sichtbar werden. Achte darauf, dass stets Rot, Grün und
    Blau getrennt manipuliert werden müssen.</p>
<p><!--Lösung-->-</p>

<br><h3>Aufgabe 2 - 2.5</h3>
<p>Modifiziere bmp_io dahingehend, dass zunächst in jeder Zeile des eingelesenen Bilds jedes ungeradzahlige Pixel durch das davor liegende geradzahlige Pixel ersetzt wird
    (horizontales Down-Sampling). Diese Veränderung hat natürlich nur bei einem der beiden Testbilder Sinn (warum?). Speichere das resultierende Bild ab. Da sich die Bildgröße bei
    dieser Operation nicht ändert, muss der Bild-Header auch nicht verändert werden. Falls du im Ergebnis keine Veränderung sehen kannst, ersetze mehr Spalten, also Spalte 1 und 2
    durch Spalte 0, dann Spalte 1, 2 und 3 durch Spalte 0 usw. Wende diese Manipulation auf die Testbilder an, bis du eine Veränderung in Form eines Moiré-Musters siehst. Notiere,
    bei welcher Verringerung du die Veränderungen beobachtest und beschreibe die Veränderungen! Erkläre das Ergebnis an Hand der von dir bestimmten Periodendauer in Pixeln.</p>
<p><!--Lösung-->-</p>

<br><h3>Aufgabe 3 - 3.1</h3>
<p>Wir wollen nun bmp_io so modifizieren, dass wir die Bitzahl reduzieren können. Dazu können wir z.B. alle RGB-Werte durch eine Potenz von 2 teilen (Integer-Division ohne
    Rest). Damit das resultierende Bild nicht dunkler wird als das Original, kompensieren wir die Operation durch Multiplikation mit derselben Zweierpotenz. Zu beachten: Der Datentyp
    hat nach wie vor eine Bittiefe von 24Bit (8bit pro Farbe!)
    (Denselben Effekt erreicht man auch durch einfaches logisches 'Verunden' mit einem entsprechenden HEX-Wert, indem man mit dem LSB beginnend Bits 'ausblendet'.)</p>
<p><!--Lösung-->-</p>

<br><h3>Aufgabe 3 - 3.2</h3>
<p>Mit dem entstandenen Programm verändern wir die in Aufgabe 1 erzeugten BMP-Dateien. Ab welcher Bitzahl tritt beim Detail-Bild und beim Flächen-Bild eine sichtbare
    Verschlechterung der Qualität ein? Wie kann man diese Verschlechterung am besten beschreiben? (Alle Ergebnisbilder ins Übungsprotokoll)</p>
<p><!--Lösung-->-</p>

<br><h3>Aufgabe 3 - 3.3</h3>
<p>Modifiziere dein Programm noch einmal so, dass auch das Differenzbild zwischen Original und bitreduziertem Bild, das heißt das Fehlerbild ausgegeben, werden kann. Dabei
    musst du auch bedenken, dass z.B. bei 1 Bit Reduzierung der Fehler nur 0 oder 1 wäre. Dieser Wertebereich wäre viel zu klein, als dass man ihn in der 8bit-Grafik noch sehen
    könnte. Daher muss der Fehler durch Multiplikation mit einer 2er Potenz verstärkt werden. In anderen Worten: Hat man vorher durch 2^n geteilt, sollte man das Differenzsignal mit
    2^(8-n-1) multiplizieren. So ist sichergestellt, dass der Verstärkungsfaktor mit der Anzahl der gelöschten Bits kleiner wird. Beachte außerdem, dass bei der Differenzbildung der
    Wert 0 Schwarz entspricht, während die Null-Linie im Bild-Wertebereich 0...255 aber bei 128, d.h. Mittelgrau, liegt. Daher muss das Differenzbild vor dem Abspeichern durch
    Addition von 128 in diesen Bereich gebracht werden.
    (Bilder all dieser Fälle ins Übungsprotokoll)</p>
<p><!--Lösung-->-</p>

</body>
</html>